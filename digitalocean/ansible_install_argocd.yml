---
- name: Deploy ArgoCD on Rancher/K3s Cluster (Fresh Start)
  hosts: os_servers
  become: yes
  gather_facts: yes
  vars: 
    argocd_namespace: argocd
    kubeconfig_path: /etc/rancher/k3s/k3s.yaml
    patches_dir: /opt/argocd-patches
    argocd_config_dir: "./argocd"
    
    # Master node (first host in inventory)
    first_master:  "{{ groups['os_servers'][0] }}"
    is_single_node: "{{ groups['os_servers'] | length == 1 }}"
    
  tasks:
    # ==========================================
    # Pre-flight Check
    # ==========================================
    - name: Verify K3s and kubectl are available
      command: kubectl version
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: kubectl_version
      changed_when: false
      when: inventory_hostname == first_master

    - name: Display K3s/kubectl version
      debug:
        msg: "{{ kubectl_version.stdout_lines }}"
      when: inventory_hostname == first_master

    - name: Check cluster health
      command: kubectl get nodes -o wide
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: cluster_nodes
      changed_when: false
      when: inventory_hostname == first_master

    - name: Display cluster nodes
      debug:
        var: cluster_nodes.stdout_lines
      when: inventory_hostname == first_master

    # ==========================================
    # Setup Directories
    # ==========================================
    - name: Create patches directory
      file:
        path: "{{ patches_dir }}"
        state: directory
        mode: '0755'
      when: inventory_hostname == first_master or is_single_node

    - name: Create temp manifests directory
      file:
        path: /tmp/argocd-manifests
        state: directory
        mode: '0755'
      when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # STEP 1: Create ArgoCD Namespace
    # ==========================================
    - name: Check if ArgoCD namespace exists
      command:  kubectl get namespace {{ argocd_namespace }}
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: argocd_ns_check
      failed_when: false
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    - name: Create ArgoCD namespace
      command: kubectl create namespace {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      when: 
        - (inventory_hostname == first_master or is_single_node)
        - argocd_ns_check.rc != 0

    - name: Verify ArgoCD namespace created
      command: kubectl get namespace {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argocd_ns_verify
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    # # ==========================================
    # # STEP 2: Install Official ArgoCD Manifests (NO PATCHES YET!)
    # # ==========================================
    # - name: Install ArgoCD from official manifests
    #   command: >
    #     kubectl apply -n {{ argocd_namespace }} -f
    #     https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
    #   environment:
    #     KUBECONFIG: "{{ kubeconfig_path }}"
    #   register: argocd_install
    #   changed_when: "'created' in argocd_install.stdout or 'configured' in argocd_install.stdout"
    #   when: inventory_hostname == first_master or is_single_node

    # - name: Wait for ArgoCD manifests to be applied
    #   pause:
    #     seconds: 10
    #   when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # STEP 2: Install ArgoCD with Server-Side Apply (RECOMMENDED FIX)
    # ==========================================
    - name: Download ArgoCD install manifest
      get_url:
        url: https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
        dest: /tmp/argocd-install.yaml
        mode: '0644'
      when: inventory_hostname == first_master or is_single_node

    - name: Split CRDs from main manifest
      shell: |
        # Extract CRDs
        kubectl apply -f /tmp/argocd-install.yaml \
          --dry-run=client -o yaml | \
          grep -A 10000 "kind: CustomResourceDefinition" > /tmp/argocd-crds.yaml || true
        
        # Extract non-CRD resources
        kubectl apply -f /tmp/argocd-install.yaml \
          --dry-run=client -o yaml | \
          grep -v "kind: CustomResourceDefinition" > /tmp/argocd-resources.yaml || true
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes

    - name: Apply ArgoCD CRDs with server-side apply (fixes annotation limit)
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        
        # Apply CRDs with server-side apply and force-conflicts
        kubectl apply -f /tmp/argocd-install.yaml \
          --server-side=true \
          --force-conflicts \
          --field-manager=argocd-installer || \
        kubectl apply -f /tmp/argocd-install.yaml \
          --validate=false
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argocd_install
      changed_when: "'created' in argocd_install.stdout or 'configured' in argocd_install.stdout"
      when: inventory_hostname == first_master or is_single_node

    - name: Cleanup temporary manifests
      file:
        path: "{{ item }}"
        state: absent
      loop:
        - /tmp/argocd-install.yaml
        - /tmp/argocd-crds.yaml
        - /tmp/argocd-resources.yaml
      when: inventory_hostname == first_master or is_single_node

    - name: Wait for ArgoCD CRDs to be established
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        kubectl wait --for condition=established \
          crd/applications.argoproj.io \
          crd/applicationsets.argoproj.io \
          crd/appprojects.argoproj.io \
          --timeout=60s
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      when: inventory_hostname == first_master or is_single_node

    - name: Wait for ArgoCD manifests to be applied
      pause:
        seconds: 10
      when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # STEP 3: Wait for Installation Jobs to Complete
    # ==========================================
    - name: Check for ArgoCD installation jobs
      command:  kubectl get jobs -n {{ argocd_namespace }}
      environment: 
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argocd_jobs_check
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    - name:  Display ArgoCD jobs
      debug:
        var: argocd_jobs_check.stdout_lines
      when: inventory_hostname == first_master or is_single_node

    - name: Wait for ArgoCD jobs to complete
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        # Give jobs a moment to appear
        sleep 5
        # Wait for jobs to complete (or timeout)
        kubectl wait --for=condition=complete job --all -n {{ argocd_namespace }} --timeout=300s 2>/dev/null || true
        echo "Jobs wait completed"
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      changed_when: false
      when:  inventory_hostname == first_master or is_single_node

    - name: Verify jobs status
      command: kubectl get jobs -n {{ argocd_namespace }} -o wide
      environment: 
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argocd_jobs_final
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    - name: Display final job status
      debug:
        var: argocd_jobs_final.stdout_lines
      when: inventory_hostname == first_master or is_single_node

    # # ==========================================
    # # STEP 4: Verify argocd-secret is Populated
    # # ==========================================
    # - name: Wait and check if argocd-secret has data
    #   shell: |
    #     export KUBECONFIG={{ kubeconfig_path }}
        
    #     # Retry check for populated secret
    #     for i in {1..20}; do
    #       DATA_SIZE=$(kubectl get secret argocd-secret -n {{ argocd_namespace }} -o jsonpath="{.data}" 2>/dev/null | wc -c)
    #       if [ "$DATA_SIZE" -gt 2 ]; then
    #         echo "Secret has data (size: $DATA_SIZE)"
    #         exit 0
    #       fi
    #       echo "Attempt $i: Secret empty, waiting..."
    #       sleep 10
    #     done
        
    #     echo "Secret still empty after 200 seconds"
    #     exit 1
    #   args:
    #     executable: /bin/bash
    #   environment:
    #     KUBECONFIG: "{{ kubeconfig_path }}"
    #   register: secret_check
    #   ignore_errors: yes
    #   when:  inventory_hostname == first_master or is_single_node

    # - name: Display secret check result
    #   debug:
    #     msg: "{{ secret_check.stdout_lines }}"
    #   when:  inventory_hostname == first_master or is_single_node

    # # ==========================================
    # # STEP 5: Create argocd-redis Secret (If Missing)
    # # ==========================================
    # - name: Create argocd-redis secret if missing
    #   shell: |
    #     export KUBECONFIG={{ kubeconfig_path }}
        
    #     if kubectl get secret argocd-redis -n {{ argocd_namespace }} &>/dev/null; then
    #       echo "argocd-redis secret already exists"
    #       exit 0
    #     fi
        
    #     echo "Creating argocd-redis secret..."
    #     REDIS_PASSWORD=$(openssl rand -base64 32)
        
    #     kubectl create secret generic argocd-redis \
    #       -n {{ argocd_namespace }} \
    #       --from-literal=auth="$REDIS_PASSWORD" \
    #       --dry-run=client -o yaml | kubectl apply -f -
        
    #     echo "argocd-redis secret created"
    #   args:
    #     executable: /bin/bash
    #   environment: 
    #     KUBECONFIG: "{{ kubeconfig_path }}"
    #   register: redis_secret_create
    #   when: inventory_hostname == first_master or is_single_node

    # - name:  Verify argocd-redis secret exists
    #   command: kubectl get secret argocd-redis -n {{ argocd_namespace }}
    #   environment:
    #     KUBECONFIG: "{{ kubeconfig_path }}"
    #   register:  redis_secret_verify
    #   retries: 5
    #   delay:  5
    #   until: redis_secret_verify.rc == 0
    #   when: inventory_hostname == first_master or is_single_node

    # # ==========================================
    # # STEP 6: Fallback - Create argocd-secret if Still Empty
    # # ==========================================
    # - name: Check if argocd-secret is still empty
    #   shell: |
    #     export KUBECONFIG={{ kubeconfig_path }}
    #     kubectl get secret argocd-secret -n {{ argocd_namespace }} -o jsonpath="{.data}" | grep -q "admin" && echo "has_data" || echo "empty"
    #   args:
    #     executable: /bin/bash
    #   environment:
    #     KUBECONFIG: "{{ kubeconfig_path }}"
    #   register: secret_final_check
    #   changed_when: false
    #   when:  inventory_hostname == first_master or is_single_node

    # - name:  Manually create argocd-secret if still empty
    #   when: 
    #     - (inventory_hostname == first_master or is_single_node)
    #     - secret_final_check.stdout == "empty"
    #   block:
    #     - name: Generate admin password
    #       set_fact:
    #         argocd_admin_password: "{{ lookup('password', '/dev/null chars=ascii_letters,digits length=16') }}"

    #     - name: Delete empty argocd-secret
    #       command: kubectl delete secret argocd-secret -n {{ argocd_namespace }} --ignore-not-found=true
    #       environment:
    #         KUBECONFIG:  "{{ kubeconfig_path }}"

    #     - name: Wait for secret deletion
    #       pause:
    #         seconds: 3

    #     - name: Create argocd-secret with password
    #       shell: |
    #         export KUBECONFIG={{ kubeconfig_path }}
    #         ADMIN_PW="{{ argocd_admin_password }}"
    #         MTIME=$(date +%s)
            
    #         kubectl -n {{ argocd_namespace }} create secret generic argocd-secret \
    #           --from-literal=admin.password="$ADMIN_PW" \
    #           --from-literal=admin.passwordMtime="$MTIME" \
    #           --dry-run=client -o yaml | kubectl apply -f -
            
    #         echo "Created argocd-secret with password"
    #       args:
    #         executable:  /bin/bash
    #       environment: 
    #         KUBECONFIG: "{{ kubeconfig_path }}"

    #     - name: Display created password
    #       debug:
    #         msg: 
    #           - "‚ö†Ô∏è ArgoCD bootstrap job failed - created secret manually"
    #           - "Admin password: {{ argocd_admin_password }}"
    #           - "SAVE THIS PASSWORD - you will need it to login!"

    # ==========================================
    # STEP 7: Wait for All Pods to Be Ready
    # ==========================================
    - name:  Wait for ArgoCD core pods to be ready
      shell:  |
        export KUBECONFIG={{ kubeconfig_path }}
        kubectl wait --for=condition=ready pod \
          -l app.kubernetes.io/part-of=argocd \
          -n {{ argocd_namespace }} \
          --timeout=60s
      args:
        executable: /bin/bash
      environment: 
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: pods_ready
      retries: 3
      delay: 10
      until: pods_ready.rc == 0
      ignore_errors: yes
      when:  inventory_hostname == first_master or is_single_node

    - name: Get ArgoCD pod status
      command: kubectl get pods -n {{ argocd_namespace }} -o wide
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argocd_pods_status
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    - name: Display pod status
      debug:
        var: argocd_pods_status.stdout_lines
      when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # STEP 8: Copy and Apply Resource Patch Files
    # ==========================================
    - name: Copy patch files to remote
      copy:
        src:  "{{ item }}"
        dest: "{{ patches_dir }}/{{ item | basename }}"
        mode: '0644'
      loop: 
        - argocd/argocd-server.json
        - argocd/argocd-repo-server.json
        - argocd/argocd-application-controller.json
        - argocd/argocd-redis.json
        - argocd/argocd-dex-server.json
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes

    - name: Apply argocd-server patch
      command: >
        kubectl patch deployment argocd-server
        -n {{ argocd_namespace }}
        --type=strategic
        --patch-file={{ patches_dir }}/argocd-server.json
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: patch_server
      changed_when:  "'patched' in patch_server.stdout or 'patched' in patch_server.stderr"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes

    - name: Apply argocd-repo-server patch
      command: >
        kubectl patch deployment argocd-repo-server
        -n {{ argocd_namespace }}
        --type=strategic
        --patch-file={{ patches_dir }}/argocd-repo-server.json
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: patch_repo
      changed_when: "'patched' in patch_repo.stdout or 'patched' in patch_repo.stderr"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors:  yes

    - name: Apply argocd-application-controller patch
      command: >
        kubectl patch statefulset argocd-application-controller
        -n {{ argocd_namespace }}
        --type=strategic
        --patch-file={{ patches_dir }}/argocd-application-controller.json
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: patch_controller
      changed_when: "'patched' in patch_controller.stdout or 'patched' in patch_controller.stderr"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes

    - name: Apply argocd-redis patch
      command: >
        kubectl patch deployment argocd-redis
        -n {{ argocd_namespace }}
        --type=strategic
        --patch-file={{ patches_dir }}/argocd-redis.json
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: patch_redis
      changed_when: "'patched' in patch_redis.stdout or 'patched' in patch_redis.stderr"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors:  yes

    - name: Apply argocd-dex-server patch
      command:  >
        kubectl patch deployment argocd-dex-server
        -n {{ argocd_namespace }}
        --type=strategic
        --patch-file={{ patches_dir }}/argocd-dex-server.json
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: patch_dex
      changed_when: "'patched' in patch_dex.stdout or 'patched' in patch_dex.stderr"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes

    # ==========================================
    # STEP 9: Rollout Restart and Wait for Pods
    # ==========================================
    - name: Restart ArgoCD deployments after patching
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        
        kubectl rollout restart deployment argocd-server -n {{ argocd_namespace }}
        kubectl rollout restart deployment argocd-repo-server -n {{ argocd_namespace }}
        kubectl rollout restart deployment argocd-redis -n {{ argocd_namespace }}
        kubectl rollout restart deployment argocd-dex-server -n {{ argocd_namespace }}
        kubectl rollout restart statefulset argocd-application-controller -n {{ argocd_namespace }}
        
        echo "Rollout restarts initiated"
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      when: inventory_hostname == first_master or is_single_node

    - name: Wait for pods to be ready after restart
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        kubectl wait --for=condition=ready pod \
          -l app.kubernetes.io/part-of=argocd \
          -n {{ argocd_namespace }} \
          --timeout=60s
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: pods_ready_final
      retries: 3
      delay: 10
      until: pods_ready_final.rc == 0
      ignore_errors: yes
      when:  inventory_hostname == first_master or is_single_node

    # ==========================================
    # STEP 10: Configure ArgoCD Ingress (Optional)
    # ==========================================
    - name: Set ArgoCD server to insecure mode (HTTP)
      command: >
        kubectl patch configmap argocd-cmd-params-cm -n {{ argocd_namespace }}
        --type merge -p '{"data":{"server.insecure":"true"}}'
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: insecure_patch
      changed_when: "'patched' in insecure_patch.stdout or 'patched' in insecure_patch.stderr"
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes

    - name:  Restart argocd-server for insecure mode
      command: kubectl rollout restart deployment argocd-server -n {{ argocd_namespace }}
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      when: inventory_hostname == first_master or is_single_node

    - name: Wait for argocd-server rollout
      command: kubectl rollout status deployment argocd-server -n {{ argocd_namespace }} --timeout=200s
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      changed_when: false
      when:  inventory_hostname == first_master or is_single_node
    
    # ==========================================
    # STEP 10.5: Apply ArgoCD Ingress
    # ==========================================
    - name: Create ArgoCD ingress manifests directory
      file:
        path:  /tmp/argocd-ingress
        state: directory
        mode: '0755'
      when: inventory_hostname == first_master or is_single_node

    - name: Copy ArgoCD ingress template to remote
      template:
        src: "{{ argocd_config_dir }}/argocd_ingress.yml.j2"
        dest: /tmp/argocd-ingress/argocd-ingress.yml
        mode: '0644'
      when: inventory_hostname == first_master or is_single_node

    - name: Apply ArgoCD Ingress
      command: kubectl apply -f /tmp/argocd-ingress/argocd-ingress.yml
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: argocd_ingress_apply
      changed_when: "'created' in argocd_ingress_apply.stdout or 'configured' in argocd_ingress_apply.stdout"
      when: inventory_hostname == first_master or is_single_node

    - name: Wait for ArgoCD Ingress to be ready
      shell:  |
        export KUBECONFIG={{ kubeconfig_path }}
        kubectl get ingress argocd-server-ingress -n {{ argocd_namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || \
        kubectl get ingress argocd-server-ingress -n {{ argocd_namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || \
        echo "pending"
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: ingress_status
      retries: 10
      delay: 15
      until: ingress_status.stdout != "pending" and ingress_status.stdout != ""
      ignore_errors: yes
      when: inventory_hostname == first_master or is_single_node

    - name: Display ArgoCD Ingress status
      command: kubectl get ingress -n {{ argocd_namespace }} -o wide
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: argocd_ingress_status
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    - name: Show ArgoCD Ingress details
      debug:
        var: argocd_ingress_status.stdout_lines
      when: inventory_hostname == first_master or is_single_node

    - name: Cleanup ArgoCD ingress temp directory
      file:
        path:  /tmp/argocd-ingress
        state: absent
      when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # STEP 11: Final Verification & Output
    # ==========================================
    - name: Get all ArgoCD secrets
      command: kubectl get secrets -n {{ argocd_namespace }}
      environment:
        KUBECONFIG:  "{{ kubeconfig_path }}"
      register: all_secrets
      changed_when: false
      when:  inventory_hostname == first_master or is_single_node

    - name: Display all secrets
      debug:
        var: all_secrets.stdout_lines
      when: inventory_hostname == first_master or is_single_node

    - name: Get final pod status
      command: kubectl get pods -n {{ argocd_namespace }} -o wide
      environment: 
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: final_pods_status
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    - name: Display final pod status
      debug:
        var: final_pods_status.stdout_lines
      when: inventory_hostname == first_master or is_single_node

    - name: Get ArgoCD admin password
      shell: |
        export KUBECONFIG={{ kubeconfig_path }}
        kubectl -n {{ argocd_namespace }} get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" 2>/dev/null | base64 -d || echo "Use manually created password"
      args:
        executable: /bin/bash
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: argocd_password
      changed_when: false
      when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # Final Installation Summary
    # ==========================================
    - name: Display ArgoCD Installation Summary
      debug:
        msg: 
          - ""
          - "=========================================="
          - "  ‚úÖ ArgoCD Installation Complete!"
          - "=========================================="
          - ""
          - "üìç Namespace: {{ argocd_namespace }}"
          - ""
          - "üîë Admin Password:"
          - "{{ argocd_password.stdout }}"
          - ""
          - "üìã Pod Status:"
          - "{{ final_pods_status.stdout_lines }}"
          - ""
          - "üîê Secrets:"
          - "{{ all_secrets.stdout_lines }}"
          - ""
          - "=========================================="
          - "  Access ArgoCD:"
          - "=========================================="
          - ""
          - "Option 1: Port-Forward (Quick)"
          - "kubectl port-forward svc/argocd-server -n {{ argocd_namespace }} 8080:443 &"
          - "Then open:  https://localhost:8080"
          - ""
          - "Option 2: Create Ingress"
          - "kubectl apply -f argocd_ingress.yml"
          - "Then access via: https://{{ argocd_domain }}"
          - ""
          - "Option 3: Access via LoadBalancer/NodePort"
          - "kubectl get svc -n {{ argocd_namespace }}"
          - ""
          - "=========================================="
          - "  Next Steps:"
          - "=========================================="
          - ""
          - "1. Login with admin and the password above"
          - "2. Change your password (Settings ‚Üí Accounts)"
          - "3. Add repositories and applications"
          - "4. Setup webhook integrations"
          - ""
          - "=========================================="
          - ""
      when: inventory_hostname == first_master or is_single_node

    # ==========================================
    # Cleanup
    # ==========================================
    - name: Remove temporary directories
      file:
        path:  "{{ item }}"
        state: absent
      loop:
        - /tmp/argocd-manifests
      when: inventory_hostname == first_master or is_single_node
      ignore_errors: yes